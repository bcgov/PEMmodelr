---
title: "02_prepare_model_params"
author: "G. Perkins"
date: "2023-03-12"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r  libraries}
#remotes::install_github("bcgov/PEMprepr", build_vignettes = TRUE)
devtools::load_all("D:\\PEM_DATA\\PEMprepr")
devtools::load_all("D:\\PEM_DATA\\PEMsamplr")
devtools::load_all("D:\\PEM_DATA\\PEMmodelr")

library(PEMprepr)
library(PEMsamplr)
library(PEMmodelr)
library(dplyr)
library(data.table)
library(tidymodels)

```

# Recursive Feature selection 


```{r}
# import list 
res_size = "5m"
mcols <- readRDS(file.path(fid$model_inputs0310[2], "full_covariate_list.rds"))

rast_list <- list.files(file.path(fid$cov_dir_1020[2],res_size), pattern = ".sdat$", full.names = T, recursive = T)
   
rast_list <- rast_list[tolower(gsub(".sdat", "", basename(rast_list))) %in% tolower(mcols)]

# read in the raster template used for modelling (i.e 5m resolution)
rstack <- terra::rast(rast_list)

subsmpl <- terra::spatSample(rstack, size = 100000, method = "regular", xy = FALSE, na.rm = TRUE) # sample raster

reduced_vars <- reduce_features(subsmpl, cutoff = 0.90, corr_plot = FALSE)

saveRDS(reduced_vars, file.path(fid$model_inputs0310[2], "reduced_covariate_list.rds"))

```


### Optional tuning optimization step (takes a long time to run)

```{r hyperparameter tuning}

# import training points
cleandat <- read.csv(file.path(fid$model_inputs0310[2], "training_pts.csv")) %>%
  dplyr::select(-X)

# tune the data 
#mpts <- mpts[1:10000,]

# filter the original points (not neighbours) and remove correlated covars
trDat <- cleandat %>%
  dplyr::filter(position %in% "Orig") %>%
  select_pure_training() %>%
  dplyr::select(mapunit1, slice, any_of(reduced_vars)) %>%
  dplyr::mutate(slice = as.factor(slice)) %>%  
  drop_na() %>% 
  mutate(mapunit1 = factor(mapunit1)) %>%  
  droplevels()
   
# # temp subsample to get it working
# mu <- c("ICHmc1_01", "ICHmc1_01a" ,  "ICHmc1_01b" ,  "ICHmc1_03",   "ICHmc1_04" ,"ICHmc1_05"  ,  "ICHmc1_06" , "ICHmc1a_01b" ,  "ICHmc2_01a", "ICHmc2_01b",   "ICHmc2_02" ,   "ICHmc2_03" ,   "ICHmc2_04" ,   "ICHmc2_05")
# 
# trDat1 <- trDat %>%
#  filter(mapunit1 %in% mu)%>%
#   droplevels()
# 
# trDat = trDat1

# tune the parameters
tune_res <- tune_rf(trDat1, output = 'full')

# show best 
best_tune_roc_auc <- show_best(tune_res, metric = "roc_auc")
best_tune_accuracy <- show_best(tune_res, metric = "accuracy")
  
 # best_tune <- select_best(tune_res, metric = "accuracy")
  tune_res %>%
    collect_metrics() %>%
    filter(.metric == "roc_auc") %>%
    dplyr::select(mean, min_n, mtry) %>%
    pivot_longer(min_n:mtry,
      values_to = "value",
      names_to = "parameter"
    ) %>%
    ggplot(aes(value, mean, color = parameter)) +
    geom_point(show.legend = FALSE) +
    facet_wrap(~parameter, scales = "free_x") +
    labs(x = NULL, y = "AUC")
  
best_tune <- select_best(tune_res, metric = "accuracy")
 
write.csv(best_tune, file.path(fid$model_inputs0310[2], "best_tuning.csv"))
 
 
```

# set up the training points by BGCs and model folders

```{r}
# set up the training points by BGC

zones <- c(as.character(unique(cleandat$bgc_cat)))

bgc_pts_subzone <- lapply(zones, function (i){ # i =  zones[1]  
  pts_subzone <- cleandat %>%
        dplyr::filter(stringr::str_detect(tid, as.character(paste0(tolower(i), "_")))) %>% 
        droplevels()
      
    if(nrow(pts_subzone) == 0){ pts_subzone = NULL} else {ppts_subzone = pts_subzone }
      pts_subzone
  })
  
# format names
names(bgc_pts_subzone) <- zones




# create a folder for each of the Bec variants to model

model_bgc <- lapply(names(bgc_pts_subzone), function(xx){
   
    xx <- names(bgc_pts_subzone[1])
  
    alldat = bgc_pts_subzone[[xx]]
    out_name = names(bgc_pts_subzone[xx])
  
    # set up output folders
    outDir = file.path(fid$model_draft[2], xx)
    if(!dir.exists(file.path(outDir))){dir.create(file.path(outDir))} 

    # check the mapunit count
    tdat <- filter_min_mapunits(alldat, min_no = 20)
    
    trDat <- tdat %>% mutate(slice = factor(slice))
  
    tpts <- trDat
    #trDat_all <- inmdata_all[complete.cases(inmdata_all[ , 7:length(inmdata_all)]),]
   
    model_report(trDat, outDir)
    

  
    # up to here
    
    
    
    
    
    ###update off-BGC units with equivalent map unit for mapped BGC
  ss_crosswalk <- fread("./_MapUnitLegend/Site_Series_Equivalents.csv") %>% filter(bgc.choose.map == bgc.choose)
  setDT(trDat)[ss_crosswalk, "target" := target_new, on = c(target = "target_old")]


    
     
})


```

